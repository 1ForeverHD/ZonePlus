{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ZonePlus is a module that enables the construction of dynamic zones. These zones utilise region checking, raycasting and the new BasePart.CanTouch property to effectively determine players and parts within their boundaries. Creating a zone is as simple as: -- Assuming we place ZonePlus in ReplicatedStorage local Zone = require ( game : GetService ( \"ReplicatedStorage\" ). Zone ) local zoneGroup = workspace . SafeZoneGroup local zone = Zone . new ( zoneGroup ) A zone takes one argument - a group . A group can be any non-basepart instance (such as a Model, Folder, etc) that contains children or descendant baseparts. Alternatively a group can be a singular basepart instance, or a table containing an array of baseparts. Info Zones are compatible with all BasePart classes, however it's recommended to use simple parts (blocks, balls, cylinders, wedges, etc) where possible as these are more efficient and accurate. Some classes for instance, such as MeshParts and UnionOperations, require additional raycast checks to verify their surface geometries. Once constructed, you can utilise zone events to determine players, parts and the localplayer within. For instance, to listen for a player entering and exiting a zone, do: zone . playerEntered : Connect ( function ( player ) print (( % s entered the zone ! ): format ( player . Name )) end ) zone . playerExited : Connect ( function ( player ) print (( % s exited the zone ! ): format ( player . Name )) end ) Info If you only needed to check for the localplayer on the client (such as for a music area system), you would alternatively use the .localPlayer events. Alternatively for one-off scenarious, you can utilise zone methods: local playersArray = zone : getPlayers () Discover the full set of methods, events and properties at the Zone module docs .","title":"Introduction"},{"location":"changelog/","text":"Changelog \u00b6","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"contributing/","text":"Contributing \u00b6","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"examples/","text":"Safe Zone \u00b6 Paint Zone \u00b6 Coin Spawner \u00b6 Voting Pads \u00b6 Random Part Generator \u00b6 Ambient Areas \u00b6 All examples can be found, viewed and edited at The Playground .","title":"Examples"},{"location":"examples/#safe-zone","text":"","title":"Safe Zone"},{"location":"examples/#paint-zone","text":"","title":"Paint Zone"},{"location":"examples/#coin-spawner","text":"","title":"Coin Spawner"},{"location":"examples/#voting-pads","text":"","title":"Voting Pads"},{"location":"examples/#random-part-generator","text":"","title":"Random Part Generator"},{"location":"examples/#ambient-areas","text":"All examples can be found, viewed and edited at The Playground .","title":"Ambient Areas"},{"location":"installation/","text":"Installation \u00b6","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"method/","text":"Detection \u00b6 ZonePlus splits items into three categories: LocalPlayer Players Parts These categories then utilise unique methods to determine whether their corresponding item type is within a zone. Info It's important to understand that unlike in v1, zones now act as a collective through the ZoneController module. This means information can be generated once in a central area and shared with relavent zones, as apposed to each zone working independently. LocalPlayer \u00b6 While a localplayer-connection is active... Perform a RotatedRegion3 check within the local player. An array of all zone group parts is used as its whitelist. Use this result to determine the zones the player is within. Update each of these returned zones and determine whether .localPlayerEntered or .localPlayerExited should be fired. If active, calculate the clock time of the next check based upon the zone.accuracy enum. Players \u00b6 While a player-connection is active... Compare the total volume of all zones against the total volume of all player characters (these are pre-determined through events instead of calculating every check) If the total characters volume is less than the total zone volume then: Iterate through each player in the server. Perform a RotatedRegion3 check within the local player. A collective of all zone group parts is used as its whitelist. Use this result to determine the zones the player is within. If a returned zone has an active player connection, update it and determine if .playerEntered(player) or .playerExited(player) should be called. Else if the total characters volume is greater than the total zone volume then: Iterate through each active zone. If the zone has an active player connection, perform a Region3 check of the zones rough area using all character parts within the server as a whitelist. Using a dictionary, match the bodyparts to their corresponding players. For each player detected, perform a precise RotatedRegion3 over their character to confirm they are exactly in the zone. Update the zone with these players and fire .playerEntered(player) and/or .playerExited(player) where necessary. If active, calculate the clock time of the next check based upon the zone.accuracy enum. Parts \u00b6 When a part-connection is formed, apply a touched event to all group-parts within the zone. When a part touches one of these group-parts, set its .CanTouch property to false Fire .partEntered(part) and form a 'tracking connection' for the part While this tracking connection is active... Perform a 'tiny region3 check' (of size (0.1, 0.1, 0.1) with the zones group parts as a whitelist) to verify the parts center is still within the zone. If this returns false, then it means the part is either on the outer bounds of the zone or exited. Now perform a whole-body RotatedRegion3 check, with the zones group parts as a whitelist. If this returns false, then the part has exited the zone. Fire .partExited(part) , disconnect the tracking connection and set the parts .CanTouch property back to true . Else if the tracking connection is still active, calculate the clock time of the next check based upon the zone.accuracy enum. If all part-connections are disconnected, disconnect all touched events and end any tracking connections. Optimisations \u00b6 A zones Region3 coordinates are rounded up to the nearest multiple of 4 to ensure it rests on the voxel grid. Region3 checks are favoured over raycasts for v2 as this enables the whole player/part to be considered as apposed to just the central position. When used in conjunction with whitelists and assuming the item is not overly-large, is almost as optimal as single raycasts. The volume comparisons enable zones to determine players inside with optimal efficiency. For instance, if a server contains a single 8x8x8 zone and 100 players of size 4x5x1 , its significantly more efficient to check only the zone (of volume 512 ), as apposed to every player (of total volume 2000 ). Similarily, if you have multiple large zones which cover a map and few players in a server, it's going to be significantly more optimal to check each player as apposed to every zone. When a region check is performed on a MeshPart or UnionOperations, additional raycast checks must be performed (due to the inaccurate bounding detection of roblox's region3 methods for these) - one ray is fired from above and below the zone to determine its intesection Y vectors and whether the item falls inbetween these. It's therefore recommened to avoid using these type of parts where possible. In the future, we may consider modifying the 'Player' detection to something similar that of 'Parts'. The .CanTouch property is still very new therefore we'd like to fully explore its benefits/weaknesses first before considering so.","title":"Method"},{"location":"method/#detection","text":"ZonePlus splits items into three categories: LocalPlayer Players Parts These categories then utilise unique methods to determine whether their corresponding item type is within a zone. Info It's important to understand that unlike in v1, zones now act as a collective through the ZoneController module. This means information can be generated once in a central area and shared with relavent zones, as apposed to each zone working independently.","title":"Detection"},{"location":"method/#localplayer","text":"While a localplayer-connection is active... Perform a RotatedRegion3 check within the local player. An array of all zone group parts is used as its whitelist. Use this result to determine the zones the player is within. Update each of these returned zones and determine whether .localPlayerEntered or .localPlayerExited should be fired. If active, calculate the clock time of the next check based upon the zone.accuracy enum.","title":"LocalPlayer"},{"location":"method/#players","text":"While a player-connection is active... Compare the total volume of all zones against the total volume of all player characters (these are pre-determined through events instead of calculating every check) If the total characters volume is less than the total zone volume then: Iterate through each player in the server. Perform a RotatedRegion3 check within the local player. A collective of all zone group parts is used as its whitelist. Use this result to determine the zones the player is within. If a returned zone has an active player connection, update it and determine if .playerEntered(player) or .playerExited(player) should be called. Else if the total characters volume is greater than the total zone volume then: Iterate through each active zone. If the zone has an active player connection, perform a Region3 check of the zones rough area using all character parts within the server as a whitelist. Using a dictionary, match the bodyparts to their corresponding players. For each player detected, perform a precise RotatedRegion3 over their character to confirm they are exactly in the zone. Update the zone with these players and fire .playerEntered(player) and/or .playerExited(player) where necessary. If active, calculate the clock time of the next check based upon the zone.accuracy enum.","title":"Players"},{"location":"method/#parts","text":"When a part-connection is formed, apply a touched event to all group-parts within the zone. When a part touches one of these group-parts, set its .CanTouch property to false Fire .partEntered(part) and form a 'tracking connection' for the part While this tracking connection is active... Perform a 'tiny region3 check' (of size (0.1, 0.1, 0.1) with the zones group parts as a whitelist) to verify the parts center is still within the zone. If this returns false, then it means the part is either on the outer bounds of the zone or exited. Now perform a whole-body RotatedRegion3 check, with the zones group parts as a whitelist. If this returns false, then the part has exited the zone. Fire .partExited(part) , disconnect the tracking connection and set the parts .CanTouch property back to true . Else if the tracking connection is still active, calculate the clock time of the next check based upon the zone.accuracy enum. If all part-connections are disconnected, disconnect all touched events and end any tracking connections.","title":"Parts"},{"location":"method/#optimisations","text":"A zones Region3 coordinates are rounded up to the nearest multiple of 4 to ensure it rests on the voxel grid. Region3 checks are favoured over raycasts for v2 as this enables the whole player/part to be considered as apposed to just the central position. When used in conjunction with whitelists and assuming the item is not overly-large, is almost as optimal as single raycasts. The volume comparisons enable zones to determine players inside with optimal efficiency. For instance, if a server contains a single 8x8x8 zone and 100 players of size 4x5x1 , its significantly more efficient to check only the zone (of volume 512 ), as apposed to every player (of total volume 2000 ). Similarily, if you have multiple large zones which cover a map and few players in a server, it's going to be significantly more optimal to check each player as apposed to every zone. When a region check is performed on a MeshPart or UnionOperations, additional raycast checks must be performed (due to the inaccurate bounding detection of roblox's region3 methods for these) - one ray is fired from above and below the zone to determine its intesection Y vectors and whether the item falls inbetween these. It's therefore recommened to avoid using these type of parts where possible. In the future, we may consider modifying the 'Player' detection to something similar that of 'Parts'. The .CanTouch property is still very new therefore we'd like to fully explore its benefits/weaknesses first before considering so.","title":"Optimisations"},{"location":"resources/","text":"Model","title":"Resources"},{"location":"zone/","text":"Zone \u00b6","title":"Zone"},{"location":"zone/#zone","text":"","title":"Zone"},{"location":"zonecontroller/","text":"ZoneController \u00b6","title":"ZoneController"},{"location":"zonecontroller/#zonecontroller","text":"","title":"ZoneController"}]}