{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#summary","title":"Summary","text":"<p>ZonePlus is a module enabling the construction of dynamic zones. These zones utilise the new Spacial Query API and BasePart.CanTouch property to effectively determine players and parts within their boundaries.</p> <p>Creating a zone is as simple as:</p> <pre><code>-- Assuming we place ZonePlus in ReplicatedStorage\nlocal Zone = require(game:GetService(\"ReplicatedStorage\").Zone)\nlocal container = workspace.SafeZoneContainer\nlocal zone = Zone.new(container)\n</code></pre> <p>Zones take one argument: a container. A container can be any non-basepart instance (such as a Model, Folder, etc) that contain descendant baseparts. Alternatively a container can be a singular basepart instance, or a table containing an array of baseparts. </p> <p>Info</p> <p>Zones are compatible with all basepart classes however it's recommended to use solely Blocks (i.e. Parts with Shape 'Block') when possible as these are better optimised (since only <code>WorldRoot:GetPartBoundsInBox</code> needs to be called instead of <code>WorldRoot:GetPartsInPart</code>).</p> <p>These group parts are then used to define the region and precise bounds of the zone.</p> <p>Info</p> <p>Zones are dynamic. This means if a group part changes size or position, or if a basepart is added to or removed from the zone group, then an internal <code>_update()</code> method will be called to recalculate its bounds.</p> <p>Once constructed, you can utilise zone events to determine players, parts and the localplayer entering or exiting a zone. For instance, to listen for a player entering and exiting a zone, do:</p> <pre><code>zone.playerEntered:Connect(function(player)\n    print((\"%s entered the zone!\"):format(player.Name))\nend)\n\nzone.playerExited:Connect(function(player)\n    print((\"%s exited the zone!\"):format(player.Name))\nend)\n</code></pre> <p>Info</p> <p>On the client you may only wish to listen for the LocalPlayer (such as for an ambient system). To achieve this you would alternatively use the <code>.localPlayer</code> events.</p> <p>Important</p> <p>Initially zone parts should be located within Workspace to function properly. If you wish to move zones outside of Workspace (e.g. to prevent them interacting with other parts), consider using zone:relocate().</p> <p>Important</p> <p>Zone parts must belong to the 'Default' (0) collision group.</p> <p>If you don't intend to frequently check for items entering and exiting a zone, you can utilise zone methods:</p> <pre><code>local playersArray = zone:getPlayers()\n</code></pre> <p>Discover the full set of methods, events and properties at the Zone API.</p>"},{"location":"#optimisations","title":"Optimisations","text":"<p>Zones by default perform up to 10 checks per second in the centre of characters. This behaviour can be changed by modifying the Accuracy and Detection of zones:</p>"},{"location":"#accuracy","title":"Accuracy","text":"<p>This determines the frequency of checks per second.</p> <p>The accuracy of a zone can be changed two ways with a corresponding Accuracy Enum:</p> <ol> <li> <p>Using the <code>zone:setAccuracy(itemName)</code> method:     <pre><code>zone:setAccuracy(\"High\")\n</code></pre></p> </li> <li> <p>Setting the <code>zone.accuracy</code> property:     <pre><code>zone.accuracy = Zone.enum.Accuracy.High\n</code></pre></p> </li> </ol> <p>By default accuracy is <code>High</code>.</p> <p>Info</p> <p>Modifying the accuracy of one zone may impact the accuracy of another due to the modules collaborative nature.</p>"},{"location":"#detection","title":"Detection","text":"<p>This determines the precision of checks.</p> <p>The way a zone detects players and parts can be changed two ways with a corresponding Detection Enum:</p> <ol> <li> <p>Using the <code>zone:setDetection(itemName)</code> method:     <pre><code>zone:setDetection(\"WholeBody\")\n</code></pre></p> </li> <li> <p>Setting the <code>zone.enterDetection</code> and <code>zone.exitDetection</code> properties:     <pre><code>zone.enterDetection = Zone.enum.Detection.WholeBody\nzone.exitDetection = Zone.enum.Detection.WholeBody\n</code></pre></p> </li> </ol> <p>By default enterDetection and exitDetection are <code>Centre</code>.</p> <p>Info</p> <p>Modifying the detection of one zone may impact the detection of another due to the modules collaborative nature.</p> <p>Warning</p> <p>Setting <code>enterDetection</code> to (<code>Zone.enum.Detection.WholeBody</code> or <code>Zone.enum.Detection.Automatic</code>) and <code>exitDetection</code> to <code>Zone.enum.Detection.Centre</code> may cause the entered and exit events to trigger rapidly when the player lies on the bounds of the zone.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#320-september-7-2021","title":"[3.2.0] - September 7 2021","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li><code>Zone:onItemEnter(characterOrBasePart, callbackFunction)</code></li> <li><code>Zone:onItemExit(characterOrBasePart, callbackFunction)</code></li> <li>An error warning when a zone is constructed using parts that don't belong to the Default collision group</li> <li>Support for non-basepart HeadParts</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Reorganised checker parts</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>A bug preventing the disconnection of tracked character parts which resulted in a slight memory leak whenever a player reset or changed bodyparts</li> </ul>"},{"location":"changelog/#310-august-28-2021","title":"[3.1.0] - August 28 2021","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li><code>Zone.fromRegion(cframe, size)</code></li> <li><code>zone:relocate()</code> - Non-workspace zones are finally a possibility! Simply call this and the zones container will be moved into a WorldModel outside of Workspace.</li> <li>CollectiveWorldModel module</li> <li><code>zone.hasRelocated</code> property</li> <li><code>zone.worldModel</code> property</li> <li><code>zone.relocationContainer</code> property</li> <li><code>CollectiveWorldModel.setupWorldModel(zone)</code></li> <li><code>CollectiveWorldModel:GetPartBoundsInBox(cframe, size, overlapParams)</code></li> <li><code>CollectiveWorldModel:GetPartBoundsInRadius(position, radius, overlapParams)</code></li> <li><code>`CollectiveWorldModel:GetPartsInPart(part, overlapParams)</code></li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li><code>Zone.new(zoneGroup)</code> to <code>Zone.new(container)</code></li> <li><code>zone.group</code> property to <code>zone.container</code></li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>\"ZoneController hrp is nil\" bug</li> </ul>"},{"location":"changelog/#300-august-27-2021","title":"[3.0.0] - August 27 2021","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li><code>Zone:trackItem(characterOrBasePart)</code></li> <li><code>Zone:untrackItem(characterOrBasePart)</code></li> <li><code>Zone.itemEntered</code> event</li> <li><code>Zone.itemExited</code> event</li> <li><code>Zone:findItem(characterOrBasePart)</code></li> <li><code>ZoneController.setGroup(settingsGroupName, properties)</code></li> <li><code>ZoneController.getGroup(settingsGroupName)</code></li> <li><code>SettingsGroup.onlyEnterOnceExitedAll</code> property</li> <li><code>Zone:bindToGroup(settingsGroupName)</code></li> <li><code>Zone:unbindFromGroup(settingsGroupName)</code></li> <li><code>Zone.settingsGroupName</code> property</li> <li><code>Zone:findPoint(position)</code></li> <li><code>ZoneController.getCharacterSize(character)</code></li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Internal behaviour to use the new Spatial Query API instead of the Region3 API.</li> <li>The default Detection from <code>Automatic</code> to <code>Centre</code>.</li> <li>The behaviour of Detection <code>Centre</code> to include the whole HumanoidRootPart instead of a singular Vector within (this was required due to the new Spatial Query API).  </li> <li><code>Zone:findPart</code> now returns array <code>touchingZoneParts</code> as its second value.</li> <li><code>Maid</code> to <code>Janitor</code> by howmanysmall.</li> <li><code>Signal</code> to <code>GoodSignal</code> by stravant.</li> <li><code>ZoneController.getTouchingZones(player)</code> to <code>ZoneController.getTouchingZones(characterOrBasePart)</code>.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>RotatedRegion3</li> <li><code>ZoneController.getCharacterRegion</code></li> <li><code>ZoneController.verifyTouchingParts</code></li> <li><code>ZoneController.vectorIsBetweenYBounds</code></li> <li><code>ZoneController.getHeightOfParts</code></li> <li><code>Automatic</code> Detection Enum.</li> </ul>"},{"location":"changelog/#223-june-17-2021","title":"[2.2.3] - June 17 2021","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>The incorrect disabling of Seats and VehicleSeats within Part Zones.</li> </ul>"},{"location":"changelog/#222-june-4-2021","title":"[2.2.2] - June 4 2021","text":""},{"location":"changelog/#improved","title":"Improved","text":"<ul> <li>The accounting of character parts when removed/added via systems like HumanoidDescriptions.</li> </ul>"},{"location":"changelog/#221-may-21-2021","title":"[2.2.1] - May 21 2021","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Compatibility for Deferred Events</li> </ul>"},{"location":"changelog/#213-may-7-2021","title":"[2.1.3] - May 7 2021","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>A bug that occured when disconnecting localPlayer events</li> </ul>"},{"location":"changelog/#212-april-15-2021","title":"[2.1.2] - April 15 2021","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li><code>playerExiting</code> not firing when the player dies and respawns immidately within the zone.</li> <li>A rare nil checking bug within <code>getTouchingZones</code> in <code>ZoneController</code>.</li> </ul>"},{"location":"changelog/#211-april-7-2021","title":"[2.1.1] - April 7 2021","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>nil comparison within ZoneController getTouchingZones line 450</li> </ul>"},{"location":"changelog/#210-march-5-2021","title":"[2.1.0] - March 5 2021","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Detection Enum</li> <li><code>zone.enterDetection</code></li> <li><code>zone.exitDetection</code></li> <li><code>zone:setDetection(enumItemName)</code></li> <li>An Optimisation section to Introduction</li> </ul>"},{"location":"changelog/#200-january-19-2021","title":"[2.0.0] - January 19 2021","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Non-player part checking! (see methods below)</li> <li>Infinite zone volume, zero change in performance - zones can now be as large as you like with no additional impact to performance assuming characters/parts entering the zone remain their normal size or relatively small</li> <li>Zones now support MeshParts and UnionOperations (however it's recommended to use simple parts where possible as the former require additional raycast checks)</li> <li>Methods<ul> <li><code>findLocalPlayer()</code></li> <li><code>findPlayer(player)</code></li> <li><code>findPart(basePart)</code></li> <li><code>getPlayers()</code></li> <li><code>getParts()</code></li> <li><code>setAccuracy(enumIdOrName)</code> -- this enables you to customise the frequency of checks with enums 'Precise', 'High', 'Medium' and 'Low'</li> <li>'Destroy' alias of 'destroy'</li> </ul> </li> <li>Events<ul> <li><code>localPlayerEntered</code></li> <li><code>localPlayerExited</code></li> <li><code>playerEntered</code></li> <li><code>playerExited</code></li> <li><code>partEntered</code></li> <li><code>partExited</code></li> </ul> </li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>A players whole body is now considered as apposed to just their central position</li> <li>Region checking significantly optimised (e.g. the zones region now rest on the voxel grid)</li> <li>Zones now act as a 'collective' which has significantly improved and optimised player and localplayer detection</li> <li>Removed all original aliases and events, including <code>:initLoop()</code> which no longer has to be called (connections are detected and handled internally automatically)</li> <li>Replaced frustrating require() dependencies with static modules</li> <li>Made Zone the parent module and others as descendants</li> <li>Removed the <code>additonalHeight</code> constructor argument - this caused confusion and added additional complexities to support</li> <li><code>:getRandomPoint()</code> now returns <code>randomVector, touchingGroupParts</code> instead of <code>randomCFrame, hitPart, hitIntersection</code></li> <li><code>zone.groupParts</code> to <code>zone.zoneParts</code></li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Rotational and complex geometry detection</li> <li><code>getRandomPoints()</code> inaccuracies</li> </ul> <pre><code>-- This constructs a zone based upon a group of parts in Workspace and listens for when a player enters and exits this group\nlocal container = workspace.AModelOfPartsRepresentingTheZone\nlocal zone = Zone.new(container)\n\nzone.playerEntered:Connect(function(player)\n    print((\"%s entered the zone!\"):format(player.Name))\nend)\n\nzone.playerExited:Connect(function(player)\n    print((\"%s exited the zone!\"):format(player.Name))\nend)\n</code></pre> <pre><code>-- This constructs a zone based upon a region, tracks a Zombie NPC, then listens for when the item (aka the Zombie) enters and exits the zone.\nlocal zoneCFrame = CFrame.new()\nlocal zoneSize = Vector3.new(100, 100, 100)\nlocal zone = Zone.fromRegion(zoneCFrame, zoneSize)\n\nzone.itemEntered:Connect(function(item)\n    print((\"%s entered the zone!\"):format(item.Name))\nend)\n\nzone.itemExited:Connect(function(item)\n    print((\"%s exited the zone!\"):format(item.Name))\nend)\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#bug-reports","title":"Bug Reports","text":"<ul> <li>To submit a bug report, open an issue with label <code>Type: Bug</code> or create a response at the discussion thread.</li> <li>Ensure your report includes a detailed explanation of the problem with any relavent images, videos, etc (such as console errors).</li> <li>Make sure to include a link to a stipped-down uncopylocked Roblox place which reproduces the bug.</li> </ul>"},{"location":"contributing/#questions-and-feedback","title":"Questions and Feedback","text":"<ul> <li>Be sure to check out the documentation and resources first before asking a question.</li> <li>We recommend submitting all questions and feedback to the discussion thread.</li> <li>You can also open an issue with label <code>Type: Question</code>.</li> </ul>"},{"location":"contributing/#submitting-a-resource-video-tutorial-port-etc","title":"Submitting a resource (video tutorial, port, etc)","text":"<ul> <li>Fancy making a tutorial or resource for ZonePlus? Feel free to get in touch and we can provide tips, best practices, etc.</li> <li>We'll feature approved resources on the resources page and often the discussion thread.</li> <li>To submit a resource, open an issue, or reach out on the discussion thread or to ForeverHD on the devforum.</li> </ul>"},{"location":"contributing/#suggestions-and-code","title":"Suggestions and Code","text":"<ul> <li>ZonePlus is completely free and open source; any suggestions and code contributions are greatly appreciated!</li> <li>To make a suggestion, open an issue with label <code>Type: Enhancement</code> or create a response at the discussion thread.</li> <li>Please open a suggestion before beginning a code contribution to ensure it's discussed through fully (we wouldn't want to waste your time!).</li> <li>Some tools you'll find useful when working on this project:<ul> <li>Rojo</li> <li>Material for MKDocs</li> <li>Roblox LSP</li> </ul> </li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>If you find any problems in the documentation, including typos, bad grammar, misleading phrasing, or missing content, feel free to file issues and pull requests to fix them.</li> <li>API documentation should be written at the top of the corresponding module under <code>--[[ module:header</code>. These comment blocks are automatically converted into markdown files and deployed to the site when pulled into the <code>main</code> branch.</li> <li>To test documentation:<ol> <li>Install Material for MKDocs.</li> <li>Visit the ZonePlus repository.</li> <li>Click Fork in the top right corner.</li> <li>Clone this fork into your local repository.</li> <li>Change directory to this clone <code>cd ZonePlus</code>.</li> <li>Swap to the development branch <code>git checkout development</code>.</li> <li>Call <code>mkdocs serve</code> within your terminal.</li> <li>Open your local website (it will look something like <code>http://0.0.0.0:8000</code>)</li> <li>Any changes to <code>mkdocs.yml</code> or the files within <code>docs</code> will now update live to this local site.</li> </ol> </li> </ul> <p>Important</p> <p>All pull requests must be made to the development branch.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#method-1-take-the-model","title":"Method 1 - Take the model","text":"<ol> <li>Take the ZonePlus model by Nanoblox.</li> <li>Open the toolbox and navigate to Inventory -&gt; My Models.</li> <li>Click ZonePlus to insert into your game and place anywhere within <code>ReplicatedStorage</code>. </li> </ol>"},{"location":"installation/#method-2-download-from-releases","title":"Method 2 - Download from Releases","text":"<ol> <li>Visit the latest release.</li> <li>Under Assets, download <code>ZonePlus.rbxm</code>.</li> <li>Within studio, navigate to MODEL -&gt; Model and insert the file anywhere within <code>ReplicatedStorage</code>. </li> </ol>"},{"location":"installation/#method-3-with-rojo","title":"Method 3 - With Rojo","text":"<ol> <li>Setup with Rojo.</li> <li>Visit the ZonePlus repository.</li> <li>Click Fork in the top right corner.</li> <li>Clone this fork into your local repository.</li> <li>Modify the <code>default.project.json</code> file to your desired location (by default ZonePlus is built directly into <code>ReplicatedStorage</code>).</li> <li>Call <code>rojo serve</code> (terminal or VSC plugin) and connect to the rojo studio plugin.</li> </ol>"},{"location":"method/","title":"Method","text":""},{"location":"method/#detection","title":"Detection","text":"<p>ZonePlus splits items into three categories:</p> <ul> <li>LocalPlayer</li> <li>Players</li> <li>Parts</li> </ul> <p>These categories then utilise unique methods to determine whether their corresponding item type is within a zone.</p> <p>Info</p> <p>It's important to understand that unlike in v1, zones now act as a collective through the ZoneController module. This means information can be generated once in a central area and shared with relavent zones, as apposed to each zone working independently.</p>"},{"location":"method/#localplayer","title":"LocalPlayer","text":"<ol> <li>While a localplayer-connection is active (i.e. when a developer connects to <code>zone.localPlayerEntered/Exited</code>)...</li> <li>Perform a WorldRoot:GetPartBoundsInBox check within the local player. An array of all zone group parts is used as its whitelist.</li> <li>Use this result to determine the zones the player is within.</li> <li>Update each of these returned zones and determine whether <code>.localPlayerEntered</code> or <code>.localPlayerExited</code> should be fired.</li> <li>If active, calculate the clock time of the next check based upon the <code>zone.accuracy</code> enum.</li> </ol>"},{"location":"method/#players","title":"Players","text":"<ol> <li>While a player-connection is active (i.e. when a developer connects to <code>zone.playerEntered/Exited</code>)...</li> <li>Compare the total volume of all zones against the total volume of all player characters (these are pre-determined through events instead of calculating every check).</li> <li>If the total characters volume is less than the total zone volume then:<ol> <li>Iterate through each player in the server.</li> <li>Perform a <code>WorldRoot:GetPartBoundsInBox</code> check over the local player. A collective of all zone group parts is used as its whitelist.</li> <li>Find the corresponding zone of these bound parts. If that zone is entirely made up of Blocks, then register instantly.</li> <li>If not, then perform a <code>WorldRoot:GetPartsInPart</code> check (which is more precise) using the previous result as its whitelist. Register these successful results.</li> <li>If a returned zone has an active player connection, update it and determine if <code>.playerEntered(player)</code> or <code>.playerExited(player)</code> should be called.</li> </ol> </li> <li>Else if the total characters volume is greater than the total zone volume then:<ol> <li>Iterate through each active zone.</li> <li>If the zone has an active player connection, perform a <code>WorldRoot:GetPartBoundsInBox</code> check of the zones rough area using all character parts within the server as a whitelist.</li> <li>Using a dictionary, match the bodyparts to their corresponding players.</li> <li>For each player detected, perform the same precise checks over their character highlighted in (3).</li> <li>Update the zone with these players and fire <code>.playerEntered(player)</code> and/or <code>.playerExited(player)</code> where necessary.</li> </ol> </li> <li>If active, calculate the clock time of the next check based upon the <code>zone.accuracy</code> enum.</li> </ol>"},{"location":"method/#parts","title":"Parts","text":"<ol> <li>When a part-connection is formed (i.e. when a developer connects to <code>zone.partEntered/Exited</code>), apply a touched event to all group-parts within the zone.</li> <li>When a part touches one of these group-parts, set its <code>.CanTouch</code> property to <code>false</code>.</li> <li>Fire <code>.partEntered(part)</code> and form a 'tracking connection' for the part.</li> <li>While this tracking connection is active...<ol> <li>Perform a 'tiny check' (of size <code>(0.1, 0.1, 0.1)</code>, using the zones group parts as a whitelist) to verify the parts center is still within the zone.</li> <li>If this returns false, then it means the part is either on the outer bounds of the zone or has exited. Now perform a whole-body <code>WorldRoot:GetPartBoundsInBox</code> (or <code>WorldRoot:GetPartsInPart</code> if more precision if required if the zone contains non-block baseparts) check, with the zones group parts as a whitelist.</li> <li>If this returns false, then the part has exited the zone. Fire <code>.partExited(part)</code>, disconnect the tracking connection and set the parts <code>.CanTouch</code> property back to <code>true</code>.</li> <li>Else if the tracking connection is still active, calculate the clock time of the next check based upon the <code>zone.accuracy</code> enum.</li> </ol> </li> <li>If all part-connections are disconnected, disconnect all touched events and end any tracking connections.</li> </ol>"},{"location":"method/#items","title":"Items","text":"<ol> <li>Same methodology as <code>Players</code>, except using tracked instances from <code>zone:trackItem(item)</code> instead of a players character.</li> </ol>"},{"location":"method/#optimisations","title":"Optimisations","text":"<ol> <li>Whitelists everywhere. ZonePlus ensures only necessary parts (such as a characters HumanoidRootPart) are tracked and then passed through to whitelists when performing checks.</li> <li>A zones Region coordinates are rounded up to the nearest multiple of 4 to ensure it rests on the voxel grid.</li> <li>The volume comparisons enable zones to determine players inside with optimal efficiency. For instance, if a server contains a single <code>8x8x8</code> zone and 100 players of size <code>4x5x1</code>, its significantly more efficient to check only the zone (of volume 512), as apposed to every player (of total volume 2000). Likewise, if you have multiple large zones which cover a map and few players in a server, it's going to be significantly more optimal to check each player as apposed to every zone.</li> <li>For the experimental part events, .Touched abuse checks are enforced to prevent parts firing these events more than the property value of whatever <code>enum.accuracy</code> is.</li> </ol>"},{"location":"resources/","title":"Resources","text":"<ul> <li>Model</li> <li>Playground</li> <li>Discussion</li> <li>Repository</li> </ul> <p>If you would like to submit a resource (such as a video tutorial, port, etc), please see contributing.</p>"},{"location":"api/zone/","title":"Zone","text":""},{"location":"api/zone/#construtors","title":"Construtors","text":""},{"location":"api/zone/#new","title":"new","text":"<p><pre><code>local zone = Zone.new(container)\n</code></pre> A container is used the define the boundaries of the zone. It can be any non-basepart instance (such as a Model, Folder, etc) that contain descendant baseparts. Alternatively a container can be a singular basepart instance, or a table containing an array of baseparts. </p>"},{"location":"api/zone/#fromregion","title":"fromRegion","text":"<p><pre><code>local zone = Zone.fromRegion(cframe, size)\n</code></pre> Constructs a zone from the given CFrame and Size. Underneath the hood, it's creating a part (or multiple parts if any size coordinage exceeds 2024), parenting this to a folder (the container), constructing a zone with this container, calling <code>:relocate()</code> on that zone (which parents it outside of workspace), then finally returning the zone.</p>"},{"location":"api/zone/#methods","title":"Methods","text":""},{"location":"api/zone/#findlocalplayer","title":"findLocalPlayer","text":"<pre><code>local isWithinZoneBool = zone:findLocalPlayer()\n</code></pre>"},{"location":"api/zone/#findplayer","title":"findPlayer","text":"<pre><code>local isWithinZoneBool = zone:findPlayer(player)\n</code></pre>"},{"location":"api/zone/#findpart","title":"findPart","text":"<pre><code>local isWithinZoneBool, touchingZoneParts = zone:findPart(basePart)\n</code></pre>"},{"location":"api/zone/#finditem","title":"findItem","text":"<pre><code>local isWithinZoneBool, touchingZoneParts = zone:findItem(basePartOrCharacter)\n</code></pre>"},{"location":"api/zone/#findpoint","title":"findPoint","text":"<pre><code>local isWithinZoneBool, touchingZoneParts = zone:findPoint(position)\n</code></pre>"},{"location":"api/zone/#getplayers","title":"getPlayers","text":"<pre><code>local playersArray = zone:getPlayers()\n</code></pre>"},{"location":"api/zone/#getparts","title":"getParts","text":"<pre><code>local partsArray = zone:getParts()\n</code></pre>"},{"location":"api/zone/#getitems","title":"getItems","text":"<pre><code>local itemsArray = zone:getItems()\n</code></pre>"},{"location":"api/zone/#getrandompoint","title":"getRandomPoint","text":"<p><pre><code>local randomVector, touchingZonePartsArray = zone:getRandomPoint()\n</code></pre> Generates random points within the zones region until one falls within its bounds. It then returns this <code>Vector3</code> and a <code>table array</code> of group parts the point falls within.</p>"},{"location":"api/zone/#trackitem","title":"trackItem","text":"<p><pre><code>zone:trackItem(characterOrBasePart)\n</code></pre> This is used to detect your own custom instances within zones, such as NPCs, and is a recommended replacement for part-events/methods.</p> <p>An item can be any BasePart or Character/NPC (i.e. a model with a Humanoid and HumanoidRootPart). Once tracked, it can be listened for with the <code>zone.itemEntered</code> and <code>zone.itemExited</code> events.</p> <p>An item will be automatically untracked if destroyed or has its parent set to <code>nil</code>.</p>"},{"location":"api/zone/#untrackitem","title":"untrackItem","text":"<pre><code>zone:untrackItem(characterOrBasePart)\n</code></pre>"},{"location":"api/zone/#bindtogroup","title":"bindToGroup","text":"<p><pre><code>zone:bindToGroup(settingsGroupName)\n</code></pre> This is used to bind the zone to a settingsGroup to enhance the default behaviour of a collection of zones. The properties of a settingsGroup can be viewed at and customised using ZoneController.setGroup.</p> <p>This method is particularly useful for zones where you want to guarantee the player/item is not in two zones at once. For example, when working with ambient/music/lighting zones which perfectly border each other.</p>"},{"location":"api/zone/#unbindfromgroup","title":"unbindFromGroup","text":"<pre><code>zone:bindToGroup(settingsGroupName)\n</code></pre>"},{"location":"api/zone/#setdetection","title":"setDetection","text":"<p><pre><code>zone:setDetection(enumIdOrName)\n</code></pre> Sets the precision of checks based upon the Detection Enum. Defaults to 'Automatic'.</p>"},{"location":"api/zone/#relocate","title":"relocate","text":"<p><pre><code>zone:relocate()\n</code></pre> Moves the zone outside of workspace into a separate WorldModel within ReplicatedStorage or ServerStorage. This action is irreversible - once called it cannot be undone.</p>"},{"location":"api/zone/#onitementer","title":"onItemEnter","text":"<p><pre><code>zone:onItemEnter(characterOrBasePart, callbackFunction)\n</code></pre> Tracks the item until it has entered the zone, then calls the given function. If the item is already within the zone, the given function is called right away.</p> <pre><code>local item = character:FindFirstChild(\"HumanoidRootPart\")\nzone:onItemEnter(item, function()\n    print(\"The item has entered the zone!\"))\nend)\n</code></pre>"},{"location":"api/zone/#onitemexit","title":"onItemExit","text":"<p><pre><code>zone:onItemExit(characterOrBasePart, callbackFunction)\n</code></pre> Tracks the item until it has exited the zone, then calls the given function. If the item is already outside the zone, the given function is called right away.</p> <pre><code>local item = character:FindFirstChild(\"HumanoidRootPart\")\nzone:onItemExit(item, function()\n    print(\"The item has exited the zone!\"))\nend)\n</code></pre>"},{"location":"api/zone/#destroy","title":"destroy","text":"<p><pre><code>zone:destroy()\n</code></pre> Disconnects all connections within the zone.</p>"},{"location":"api/zone/#events","title":"Events","text":""},{"location":"api/zone/#localplayerentered","title":"localPlayerEntered","text":"<p>{client-only} <pre><code>zone.localPlayerEntered:Connect(function()\n    print(\"you entered the zone!\")\nend)\n</code></pre></p>"},{"location":"api/zone/#localplayerexited","title":"localPlayerExited","text":"<p>{client-only} <pre><code>zone.localPlayerExited:Connect(function()\n    print(\"you exited the zone!\")\nend)\n</code></pre></p>"},{"location":"api/zone/#playerentered","title":"playerEntered","text":"<pre><code>zone.playerEntered:Connect(function(player)\n    print((\"player '%s' entered the zone!\"):format(player.Name))\nend)\n</code></pre>"},{"location":"api/zone/#playerexited","title":"playerExited","text":"<pre><code>zone.playerExited:Connect(function(player)\n    print((\"player '%s' exited the zone!\"):format(player.Name))\nend)\n</code></pre>"},{"location":"api/zone/#partentered","title":"partEntered","text":"<pre><code>zone.partEntered:Connect(function(part)\n    print((\"part '%s' entered the zone!\"):format(part.Name))\nend)\n</code></pre> <p>Info</p> <p>This event works only for unanchored parts and may interfere with the parts CanCollide property. It's recommended to use itemEntered instead where possible which is more optimal and overcomes these problems. </p>"},{"location":"api/zone/#partexited","title":"partExited","text":"<pre><code>zone.partExited:Connect(function(part)\n    print((\"part '%s' exited the zone!\"):format(part.Name))\nend)\n</code></pre> <p>Info</p> <p>This event works only for unanchored parts and may interfere with the parts CanCollide property. It's recommended to use itemExited instead where possible which is more optimal and overcomes these problems. </p>"},{"location":"api/zone/#itementered","title":"itemEntered","text":"<p><pre><code>zone.itemEntered:Connect(function(item)\n    print((\"item '%s' entered the zone!\"):format(item.Name))\nend)\n</code></pre> See icon:trackItem for further details on items.</p>"},{"location":"api/zone/#itemexited","title":"itemExited","text":"<p><pre><code>zone.itemExited:Connect(function(item)\n    print((\"item '%s' exited the zone!\"):format(item.Name))\nend)\n</code></pre> See icon:trackItem for further details on items.</p>"},{"location":"api/zone/#properties","title":"Properties","text":""},{"location":"api/zone/#accuracy","title":"accuracy","text":"<p><pre><code>local accuracyEnumId = zone.accuracy --[default: 'Zone.enum.Accuracy.High']\n</code></pre> To change <code>accuracy</code> you can use setAccuracy or do:</p> <pre><code>zone.accuracy = Zone.enum.Accuracy.ITEM_NAME\n</code></pre> <p>A list of Accuracy enum items can be found at Accuracy Enum.</p>"},{"location":"api/zone/#enterdetection","title":"enterDetection","text":"<p><pre><code>local enterDetection = zone.enterDetection --[default: 'Zone.enum.Detection.Automatic']\n</code></pre> To change both detection types use setDetection otherwise to set individually do:</p> <pre><code>zone.enterDetection = Zone.enum.Detection.ITEM_NAME\n</code></pre> <p>A list of Detection enum items can be found at Detection Enum.</p>"},{"location":"api/zone/#exitdetection","title":"exitDetection","text":"<p><pre><code>local exitDetection = zone.exitDetection --[default: 'Zone.enum.Detection.Automatic']\n</code></pre> To change both detection types use setDetection otherwise to set individually do:</p> <pre><code>zone.exitDetection = Zone.enum.Detection.ITEM_NAME\n</code></pre> <p>A list of Detection enum items can be found at Detection Enum.</p>"},{"location":"api/zone/#autoupdate","title":"autoUpdate","text":"<p><pre><code>local bool = zone.autoUpdate --[default: 'true']\n</code></pre> When <code>true</code>, the zone will update when its group parts change size or position, or when a descendant group part is added or removed from the group.</p>"},{"location":"api/zone/#respectupdatequeue","title":"respectUpdateQueue","text":"<p><pre><code>local bool = zone.respectUpdateQueue --[default: 'true']\n</code></pre> When <code>true</code>, will prevent the internal <code>_update()</code> from being called multiple times within a 0.1 second period.</p>"},{"location":"api/zone/#zoneparts","title":"zoneParts","text":"<p>{read-only}</p> <p>An array of baseparts, defined in the <code>container</code> constructor parameter, that form the zone.</p>"},{"location":"api/zone/#region","title":"region","text":"<p>{read-only}</p>"},{"location":"api/zone/#volume","title":"volume","text":"<p>{read-only}</p>"},{"location":"api/zone/#worldmodel","title":"worldModel","text":"<p>{read-only}</p>"},{"location":"api/zone_controller/","title":"ZoneController","text":""},{"location":"api/zone_controller/#functions","title":"Functions","text":""},{"location":"api/zone_controller/#getzones","title":"getZones","text":"<pre><code>local zonesArray = ZoneController.getZones()\n</code></pre>"},{"location":"api/zone_controller/#gettouchingzones","title":"getTouchingZones","text":"<pre><code>local touchingZonesArray, touchingPartsDictionary = ZoneController.getTouchingZones(player)\n</code></pre>"},{"location":"api/zone_controller/#setgroup","title":"setGroup","text":"<pre><code>local settingsGroup = ZoneController.setGroup(settingsGroupName, properties)\n</code></pre> <p><code>properties</code> is a dictionary defining the groups settings. The default properties are: <pre><code>{\n    onlyEnterOnceExitedAll = true, -- When set to `true`, it prevents items (players, parts, etc) from entering multiple zones at once within that group.\n}\n</code></pre> A zone can be bound to a group using zone:bindToGroup.</p>"},{"location":"api/zone_controller/#getgroup","title":"getGroup","text":"<pre><code>local settingsGroup = ZoneController.getGroup(settingsGroupName)\n</code></pre>"}]}